'''
Как известно, функция map() принимает функцию и итерируемый объект и возвращает итератор, 
элементами которого являются элементы итерируемого объекта, к которым была применена переданная функция. 
Нередко элементами итерируемого объекта являются коллекции (списки, кортежи, ..), тогда внутри переданной 
функции нам приходится обращаться к каждому элементу этих коллекций по индексу. Например:

persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]

full_names = map(lambda tup: tup[0] + ' ' + tup[1], persons)
Было бы удобно иметь функцию, назовем ее starmap(), которая бы принимала функцию не с одним аргументом, а с несколькими — каждым элементом коллекции:

persons = [('Timur', 'Guev'), ('Arthur', 'Kharisov')]

full_names = starmap(lambda name, surname: f'{name} {surname}', persons)
Реализуйте функцию starmap() с использованием функции map(), которая принимает два аргумента:

func — функция
iterable — итерируемый объект, элементами которого являются коллекции
Функция starmap() должна работать аналогично функции map(), то есть возвращать итератор, элементами которого являются элементы итерируемого объекта iterable, 
к которым была применена функция func, с единственным отличием: func должна принимать не один аргумент — коллекцию (элемент iterable), 
а каждый элемент этой коллекции в качестве самостоятельного аргумента.

Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию starmap(), но не код, вызывающий ее.

Примечание 2. Тестовые данные доступны по ссылкам:

Архив с тестами
GitHub
Sample Input 1:

pairs = [(1, 3), (2, 5), (6, 4)]

print(*starmap(lambda a, b: a + b, pairs))
Sample Output 1:

4 7 10
Sample Input 2:

points = [(1, 1, 1), (1, 1, 2), (2, 2, 3)]

print(*starmap(lambda x, y, z: x * y * z, points))
Sample Output 2:

1 2 12
'''
def starmap(func :callable,*args):
    return [func(*vals) for vals in args[0]]


pairs = [(1, 3), (2, 5), (6, 4)]

print(*starmap(lambda a, b: a + b, pairs))